# 상태

- 객체는 외부에 드러나느 행위와 행위를 지원하기 위한 상태를 묶어주는 단위이다.
- 따라서 객체지향 언어는 상태를 다루는데 적합한 전략이다. 객체지향 언어에서는 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대해 매우 엄격한 접근 권한을 적용해서 "알지 못하는 사이에" 상태가 변해버리는 문제를 막아준다.

### 상태관리 
- 유사한 상태를 묶어서 관리하고, 각 상태를 별도로 관리해라
- 어떤 상태가 유사한 상태인가?   
    1) 두개의 상태가 동일한 연산 안에서 사용되고 
    2) 동일한 시점에서 생성되고 소멸될 때

## 접근 
- 메모리 접근은 현재 저장된 값을 반환하는 일종의 계산인 반면, 계산은 아직 저장되지 않은 메모리 값을 읽는 값 접근이라고 표현할 수 있다. 
- 뭘 저장하고 계산할지 정하는 것은 프로그램의 가독성, 유연성, 성능에 영향을 미친다. 
- 각 객체는 조그만 메모리를 갖는 별도의 작은 컴푸터와 같으며 저장소를 관리하는 역할을 한다.
- 객체간 접근의 용이성을 위해 객체간의 독립성을 포기하는것은 좋지 않다.

### 직접 접근
```
x = 10;
```
- 표현이 명확하다.
- 변수에 값을 저장하는것 이외의 유연성은 없다. 
- 프로그래머의 사고수준보다 낮은 수준의 세부 구현 사용
- 직접접근은 원활한 커뮤니케이션을 방해하는 요소이다.
```java
doorRegister = 1 ;
```
```java
openDoor();
```
```java
// 위의 예제코드 보다 객체와 객체에 대한 행위가 명확하다.
door.open();
```

### 간접 접근
- 메소드 호출을 통해 상태 변화를 숨길 수 있다.
- 2개이상의 데이터간에 의존관계가 존재하는경우 유용하다.

### 공용상태 
- 여러 연산에서 같은 데이터 요소를 사용하는 경우 클래스에 필드를 선언해서 사용하는 것이 좋다.
- 각 객체의 공용상태는 모두 범위와 생명기간이 같아야한다. 
- 특정 메소드에서만 유효한 필드를 생성하는 것 보다는 인자를 사용하거나 도우미 객체를 사용하는 것이 좋다.

### 가변상태 
- 가변 상태는 데이터 요소의 이름을 키, 데이터를 값으로 갖는 맵으로 표현된다. 
- 가변 상태는 공용 상태에 비해 훨씬 유연하지만 커뮤니케이션은 어렵게 한다. 
- 각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에 사용이 정당화 된다. 
- 가능하다면 공용상태를 사용하고, 경우에 따라 어떤 필드가 필요할지 확실치 않을때만 가변상태를 사용하라  

### 외재상태
- 어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하는 편이 낫다
- 외재 상태사용시 객체의 복사와 디버깅이 어려워진다.
# 상태

- 객체는 외부에 드러나느 행위와 행위를 지원하기 위한 상태를 묶어주는 단위이다.
- 따라서 객체지향 언어는 상태를 다루는데 적합한 전략이다. 객체지향 언어에서는 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대해 매우 엄격한 접근 권한을 적용해서 "알지 못하는 사이에" 상태가 변해버리는 문제를 막아준다.

### 상태관리 
- 유사한 상태를 묶어서 관리하고, 각 상태를 별도로 관리해라
- 어떤 상태가 유사한 상태인가?   
    1) 두개의 상태가 동일한 연산 안에서 사용되고 
    2) 동일한 시점에서 생성되고 소멸될 때

## 접근 
- 메모리 접근은 현재 저장된 값을 반환하는 일종의 계산인 반면, 계산은 아직 저장되지 않은 메모리 값을 읽는 값 접근이라고 표현할 수 있다. 
- 뭘 저장하고 계산할지 정하는 것은 프로그램의 가독성, 유연성, 성능에 영향을 미친다. 
- 각 객체는 조그만 메모리를 갖는 별도의 작은 컴푸터와 같으며 저장소를 관리하는 역할을 한다.
- 객체간 접근의 용이성을 위해 객체간의 독립성을 포기하는것은 좋지 않다.

### 직접 접근
```
x = 10;
```
- 표현이 명확하다.
- 변수에 값을 저장하는것 이외의 유연성은 없다. 
- 프로그래머의 사고수준보다 낮은 수준의 세부 구현 사용
- 직접접근은 원활한 커뮤니케이션을 방해하는 요소이다.
```java
doorRegister = 1 ;
```
```java
openDoor();
```
```java
// 위의 예제코드 보다 객체와 객체에 대한 행위가 명확하다.
door.open();
```

### 간접 접근
- 메소드 호출을 통해 상태 변화를 숨길 수 있다.
- 2개이상의 데이터간에 의존관계가 존재하는경우 유용하다.

### 공용상태 
- 여러 연산에서 같은 데이터 요소를 사용하는 경우 클래스에 필드를 선언해서 사용하는 것이 좋다.
- 각 객체의 공용상태는 모두 범위와 생명기간이 같아야한다. 
- 특정 메소드에서만 유효한 필드를 생성하는 것 보다는 인자를 사용하거나 도우미 객체를 사용하는 것이 좋다.

### 가변상태 
- 가변 상태는 데이터 요소의 이름을 키, 데이터를 값으로 갖는 맵으로 표현된다. 
- 가변 상태는 공용 상태에 비해 훨씬 유연하지만 커뮤니케이션은 어렵게 한다. 
- 각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에 사용이 정당화 된다. 
- 가능하다면 공용상태를 사용하고, 경우에 따라 어떤 필드가 필요할지 확실치 않을때만 가변상태를 사용하라  

### 외재상태
- 어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하는 편이 낫다
- 외재 상태사용시 객체의 복사와 디버깅이 어려워진다.


### 변수
- 변수의 종류 
    - 지역변수 : 현재 범위에서만 접근 가능
    - 필드변수 : 같은 객체 내에서 접근 가능
    - 정적변수 : 같은 클래스의 어떤 객체에서도 접근 가능
- 다양한 종류의 변수를 사용 할때, 이름을 통해 변수의 종류를 나타내는 것이 좋다.
- 하지만 사용하는 변수의 종류를 가능한 줄이는게 더 좋다.
- 변수의 생명기간은 가급적이면 변수의 범위에 가까워지도록 하라.
- 같은 범위에서 정의되는 변수들은 모두 같은 생명기간을 갖게 하라.
- 여러 데이터를 저장하는 변수(컬렉션)이름은 복수형으로 만들어라.

### 지역변수
지역변수는 변수가 선언된 지점이 속한 범위에서만 접근 가능하다. 사용되기 직전에 가급적 최소 범위 내에서 선언하는것이 좋다.
- 지역변수의 역할
    - 컬렉터 : 이후 사용할 정보 모음
    - 카운터 : 특정 객체싀 수를 저장
    - 설명 : 복잡한 표현을 해야하는 경우, 표현 내용을 지역변수에 저장
    (설명이 목적인 지역변수는 도우미 메소드로 바꿀수도 있다.)
    - 재사용 : 값이 바뀌지만 바뀌기전 값을 다시 사용해야 하는 경우 그 값을 지역변수에 저장 할 수 있다. 
    - 원소 : 현재 사용하는 컬렉션의 원소를 저장하기 위해 사용
    예) 
    ```java
        boradcast() {
            for(Source eachSender: GetSenders()) {
                for(Receiver eachReceiver: GetReCeiver()){
                    ...
                }
            }
        }
    ```

### 필드
- 필드의 범위와 생명기간은 필드를 갖고 있는 객체와 같다. 
- 필드는 객체 전반에 걸쳐 사용되므로 모든 필드는 클래스의 가장 앞이나 뒤에 한꺼번에 선언하는 것이 좋다
- 필드의 역할
    - 도우미 : 여러메소드에서 객체를 파라미터로 전달 받는다면, 파라미터를 도우미 필드로 바꾸고,
            생성자에서 필드를 설정하는 방법을 고려하는것이 좋다.
    - 플래그 : 객체가 두가지 다른 방식으로 동작할때 사용할 수 있다. 하지만 플래그에 따라 결정을 내리는 코드가 중복되어 있다면, 전략필드를 사용하는 것이 좋다.
    - 전략 : 객체의 연산을 하는 다른 방법이 있을때, 그 부분을 수행하는 객체를 필드에 저장하라.
    - 상태 : 객체의 행위양식을 결정한다는 점에서 전략필드와 유사. 하지만 상태 필드는 스스로 다음 상태를 설정한다. 
    - 부속 : 객체의 소유객체나 데이터를 저장

### 파라미터 
상태를 다른객체에 전달하는 방법에는 비전용 변수(필드나 정적 필드)를 사용하는 방법과 파라미터를 사용하는 방법이 있는데, 비전용변수를 사용하는 경우에는 클래스간 강한 의존성이 발생한다. 
따라서 정적 변수와 파라미터를 둘다 사용할 수 있는 경우라면 언제나 파라미터를 사용하는 것이 좋다.
- 단일 파라미터는 약한 의존
- 반복해서 같은 파라미터를 사용하면 의존성이 커진다.
- 이런 경우에는 파라미터를 객체 내로 옮기는것이 의존성을 감소시키는 방법이다.

### 수집 파라미터
- 메소드 호출의 결과를 통합 할때, 결과값이 정수처럼 단순한 경우 메소드의 결과값을 반환하는 것이다.
- 좀더 복잡한 방식을 통해 결과를 통합해야 하는 경우라면, 파라미터를 전달해서 결과를 수집하는 편이 더 직관적이다.

### 옵션 파라미터
- 파라미터를 전달할때 반드시 필요한 파라미터는 앞에서 전달하고, 옵션 파라미터는 뒤에 전달한다.

### 가변 인자
- 어떤 메소드가 특정 타입의 파라미터를 여러개 취할 때 간단한 해결책은 컬렉션을 파라미터로 사용하는 것이다. 하지만 메소드 호출 하는 쪽 코드가 지저분해짐.
- 위와 같은 문제를 해결하기 위해 자바에서는 다양한 개수의 인자를 취하는 메커니즘 제공
    - 메소드를 method(Class... classes)와 같이 선언하면 다음과 같이 임의의 수의 인자를 사용하여 메소드를 호출할 수 있다.
    ```java
    object.index(key1, key2)
    ```
    - 가변 인자는 항상 마지막 파라미터여야 한다. 
    - 가변인자와 옵션인자를 모두 사용하는 경우, 옵션인자가 가변인자 앞에 온다.

### 파라미터 객체
- 여러개의 파라미터가 함께 여러 메소드로 전달된다면 이들을 하나의 객체로 만드는 것이 좋다.
- 파라미터 객체를 사용하면 코드가 짧아지고, 의도를 좀더 명확히 전달 할 수 있다.
- 파라미터 객체는 가독성에도 도움을 주지만, 여러 파라미터 리스트에 데이터가 함께 나타난다는 이야기는 그 데이터들이 밀접한 연관성이 있다는 로직의 중요한 의미를 뜻하기도 한다.
- 파라미터 객체는 코드를 좀더 읽기 쉽고, 잘 나뉘어 지게하여 테스트하기 쉽게 한다.

### 상수
- 변하지 않는 데이터를 프로그램 곳곳에서 사용해야하는 경우, 컴파일 하는 시점에 그 값을 알고 있다면 static final로 선언하고 그 변수를 참조하게 하라.
- 상수를 사용하면 실수를 줄일 수가 있다. 
- 상수 이름을 통해 그 값의 뜻을 전달할 수 있기 때문에 가독성이 높아진다.
- 상수를 인자로 취하는 인터페이스는 각 상수 값에 대해 별도의 메소드를 제공하는것이 좋다.

### 역할 제시형 작명
- 변수 이름을 작성할때 변수의 역할을 알 수 있는 가급적 짧고 명료한 이름을 사용하는 것이 좋다.
- 단어를 축약해서 변수이름을 짓는다면 가독성을 희생하고 타이핑의 효율성을 택한것이지만, 하번 작성된 코드는 여러차례 읽히므로 옳지 못한 방법이다.

### 선언 타입
- 변수 선언은 가급적 일반적인 타입으로 하는 것이 좋다.
- 일반적인 선언 타입을 사용하면 이후 수정에서 실제 클래스 구현을 변경 할 수 있다.
    (어떤 변수를 ArrayList로 선언한 후 HashSet으로 변경하기 어렵다. 하지만 변수를 Collection으로 선언했다면 수정이 쉽다.)

### 초기화
- 변수의 초기화는 가급적 선언과 함께 하는 것이 좋다. 
- 초기화에 드는 비용이 비싼 변수의 경우, 생성과 초기돠를 분리하는 것이 나을 수 있다.

### 열성적 초기화
- 열성적 초기화는 변수가 선언되거나 생성되자마자 초기돠 한다. 
- 열성적 초기화를 사용하면 모든 변수가 초기화 이후에 사용되는 것을 보장할 수 있다.
- 선언문에서 필드를 초기화할 수 없다면 생성자에서 초기화하라.

### 게으른 초기화
- 초기화 비용이 상당하고 비용이 상당하고 비용부담을 가급적 늦추고 싶다면(그 변수가 사용되지 않을수 있으므로) 취득메소드를 만들고 처음으로 해당 메소드가 호출될때 객체를 초기화 하면 된다.
- 게으른 초기화를 사용하면, 독자는 필드의 구현 타입을 확인하기 위해 최소한 두 군데를 확인해야 한다.
