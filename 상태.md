# 상태

- 객체는 외부에 드러나느 행위와 행위를 지원하기 위한 상태를 묶어주는 단위이다.
- 따라서 객체지향 언어는 상태를 다루는데 적합한 전략이다. 객체지향 언어에서는 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대해 매우 엄격한 접근 권한을 적용해서 "알지 못하는 사이에" 상태가 변해버리는 문제를 막아준다.

### 상태관리 
- 유사한 상태를 묶어서 관리하고, 각 상태를 별도로 관리해라
- 어떤 상태가 유사한 상태인가?   
    1) 두개의 상태가 동일한 연산 안에서 사용되고 
    2) 동일한 시점에서 생성되고 소멸될 때

## 접근 
- 메모리 접근은 현재 저장된 값을 반환하는 일종의 계산인 반면, 계산은 아직 저장되지 않은 메모리 값을 읽는 값 접근이라고 표현할 수 있다. 
- 뭘 저장하고 계산할지 정하는 것은 프로그램의 가독성, 유연성, 성능에 영향을 미친다. 
- 각 객체는 조그만 메모리를 갖는 별도의 작은 컴푸터와 같으며 저장소를 관리하는 역할을 한다.
- 객체간 접근의 용이성을 위해 객체간의 독립성을 포기하는것은 좋지 않다.

### 직접 접근
```
x = 10;
```
- 표현이 명확하다.
- 변수에 값을 저장하는것 이외의 유연성은 없다. 
- 프로그래머의 사고수준보다 낮은 수준의 세부 구현 사용
- 직접접근은 원활한 커뮤니케이션을 방해하는 요소이다.
```java
doorRegister = 1 ;
```
```java
openDoor();
```
```java
// 위의 예제코드 보다 객체와 객체에 대한 행위가 명확하다.
door.open();
```

### 간접 접근
- 메소드 호출을 통해 상태 변화를 숨길 수 있다.
- 2개이상의 데이터간에 의존관계가 존재하는경우 유용하다.

### 공용상태 
- 여러 연산에서 같은 데이터 요소를 사용하는 경우 클래스에 필드를 선언해서 사용하는 것이 좋다.
- 각 객체의 공용상태는 모두 범위와 생명기간이 같아야한다. 
- 특정 메소드에서만 유효한 필드를 생성하는 것 보다는 인자를 사용하거나 도우미 객체를 사용하는 것이 좋다.

### 가변상태 
- 가변 상태는 데이터 요소의 이름을 키, 데이터를 값으로 갖는 맵으로 표현된다. 
- 가변 상태는 공용 상태에 비해 훨씬 유연하지만 커뮤니케이션은 어렵게 한다. 
- 각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에 사용이 정당화 된다. 
- 가능하다면 공용상태를 사용하고, 경우에 따라 어떤 필드가 필요할지 확실치 않을때만 가변상태를 사용하라  

### 외재상태
- 어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하는 편이 낫다
- 외재 상태사용시 객체의 복사와 디버깅이 어려워진다.
