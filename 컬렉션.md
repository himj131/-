# 컬렉션
- 컬렉션 구현은 주로 성능에 관련된 의도를 전달한다.
- 컬렉션은 데이터의 변형이나 몇개의 데이터를 사용하느냐를 표현하고 있다.
- 어떤 컬렉션을 사용하느냐에 따라 프로그래머는 다양한 정보를 독자에게 전달 할 수 있다.

## 컬렉션 메타포
### 1. 여러값을 가진 변수
- 컬렉션 변수는 여러 객체를 한번에 가리키는 역할을 한다. 
- 여느 변수와 마찬가지로 컬렉션 변수에도 값을 할당하고, 값을 얻어올수 있으며 변수 메세지를 보낼 수 있다.

### 2. 객체
- 컬렉션의 값을 얻는것도 가능하고, 인자로 전달하는것도 가능하며 동등성 테스트, 메세지 보내기가 가능하다. 
- 컬렉션은 여러 관련있는 인터페이스와 구현의 집합이므로 확장된 인터페이스와 새로운 구현을 통해 확장이 가능하다. (ex)버전인터페이스)
- 변수 값이 아닌 변수 자체를 인자로 전달하는 참조 호출이 가능하다.
- 참조 호출은 예상치 못한 결과를 가져올수 있으므로 이런 상황을 피하기 위해 컬렉션 사용에는 몇가지 규범이 있다.

### 3. 수학적 집합
- 수학의 집합이 여러 원소의 모임인 것과 마찬가지로 컬렉션은 객체의 모임이다.
- 집합 메타포를 모두 컬렉션에 적용하지는 않고, 크기(size())를 구하는 것이나, 집합에 속해있는지 알아보는(contains())것 등의 부분적으로만 적용하고 있다.

## 이슈
- 컬렉션을 사용할때에는 가급적 가장 일반적인 인터페이스를 사용해서 선언하고, 가장 구체적인 구현 클래스를 사용하는 것이 좋다. 
    > 같은 객체를 Iterable, Collection, List등 다양한 타입을 사용하는 것보다 모든곳에서 List로 선언하는 것이 더 깔끔할 수 있다.
- 컬렉션의 선택은 성능에 관한 프로그래머의 의도를 전달한다.  
- 적절한 컬렉션 사용은 시간과 공간면에서 모두 프로그램을최적화 시킬수 있다.

## 컬렉션으로 표현하는 개념
- 크기 : 고정크기, 가변형
- 원소간의 순서 : 순서정보가 보전되어야 하는지
- 원소의 독자성 (uniqueness) : 어떤 원소가 컬렉션에 속해있는지 여부나, 몇번 나타나는지
- 접근 : 순차 열람 or 키를 통해 원소를 가져올것인지

> 성능과 컬렉션 사이에 밀접한 관계가 있는 이유는 컬렉션의 크기에 제한이 없기 때문이다. 성능에 중점을 둔 컬렉션을 사용한 프로그래밍을 할 때 가장 단순한 구현으로 시작해서, 필요에 따라 좀더 특화된 컬렉션을 사용하는것을 권장한다. 
성능과 관련된 결정을 내릴때면 설계에 어느정도 변화가 필요하더라도 그 변화에 따른 영향 범위가 최소한이 되도록 노력한다.


## 인터페이스
### 배열
- 가장 단순한 컬렉션 인터페이스
- 배열의 크기는 생성시 고정
- 단순 연산의 경우 다른 컬렉션에 비해 시간, 공간면에서 효율적이다
- 다른 컬렉션과 다른 프로토콜을 갖고있어 배열을 다른 종류의 컬렉션으로 별환하는 일이 상대적으로 복잡하다.

### Iterable
- 지원하는 기능은 순차 열람 뿐이고 크기 측정 메소드도 없다.
- 수정에 대한 여부를 판단할 수 없고 Iterator를 갖고 있다면 remove()메소드를 사용해서 원소를 제거할 수 는 있다.
- Iterable의 하위 인터페이스들이 좀더 유용한 기능을 지원한다.

### Collection
- Iterable을 상속받아 원소 추가, 삭제, 검색, 크기등의 메소드를 추가로 지원한다.
- addAll(), retainAll(), removeAll()의 결과로 컬렉션 자체를 바꾸는 대신 새로 할당된 컬렉션을 반환한다.

### List
- Collection을 기반으로 원소간에 정해진 순서을 부여한 것
- List를 사용하면 컬렉션상에서의 인덱스를 통해 어떤 원소네 접근할 수 있다.
- 원소 사이의 상호작용(특히 원소간의 순서)이 있는 경우 사용한다.

### Set
- 중복 원소를 허용하지 않고, 순서가 없는 컬렉션
- Set에 원소를 추가하면 변경된 컬렉션이 아닌 컬렉션 자체가 바뀐다.
- 컬렉션에 원소가 속해있는지 여부가 중요하고, 출현 횟수가 중요하지 않은 경우 유용

### SortedSet
- 중복 원소가 없는 순서가 있는 컬렉션
- SortedSet는 Comparator에 의해 순서를 정한다. (명시적인 순서를 정하지 않은 경우 기본 정렬)

### Map
- List처럼 키를 사용해 원소를 저장하고 이때 키는 임의의 객체가 된다.
- Map의 키는 중복이 불가하지만 원소데이터는 중복 사용이 가능하다.
- 순서가 보장 되지 않는다.
- Map은 내부적으로 키에 대한 컬렉션과 데이터에 대한 컬렉션, 2개의 컬렉션을 유지한다.
- 외재상태나 변수상태에 많이 사용아여 키를 객체로 테이터를 상태로 사용할때 유용하다.

## 구현
- 컬렉션에 대해 구현 클래스를 선택하는 것은 주로 성능과 관련이 있다.
- 컬렉션의 크기도 컬렉션 구현시 고려해야할 대상이다. 
- 우선 단순한 구현으로 시작한 후 경험에 따라 튜닝을 하는 것이 좋다.

### Collection
- Collection 인터페이스에 대한 기본 구현 클래스는 ArrayList이다.
- ArrayList사용시 성능상 문제가 될만한 부분은 컬렉션의 크기에 비례해서 연산이 커지는 contains()와 이 메소드를 이용하는 다른 메소드들(remove())이다.
- 이러한 메소드들이 성능을 제약한다면 HashSet으로 바꾸는걸 고려해보는 것이 좋다(중복제거 가능한 경우)

### List
- Collection 프로토콜에 원소 사이의 순서를 부여한 것
- List의 구현체중 자주 쓰이는 것으로는 ArrayList, LinkedList가 있다.
    - ArrayList 는 원소 접근이 빠르고, 원소 추가/제거가 느림
    - LinkedList는 원소 접근이 느리고, 원소 추가/제거가 빠름
    - add()나 remove()가 많은 프로그램이라면 LinkedList를 사용하는 것이 좋다.

### Set
- 구현체로 HashSet, LinkedHashSet, TreeSet이 많이 쓰인다.
    - HashSet은 가장 빠르지만 원소간 순서를 보장해주지 않는다.
    - LinkedHashSet은 원소간 순서를 삽입된 순서로 보장해 준다. 하지만 추가/삭제시 30% 시간이 더 걸린다.
    - TreeSet은 Comparator에 따라 원소를 정렬하지만 원소추가/삭제 시간이 logn에 비례해서 커진다.

### Map
- HashMap은 가장 빠르고 단순하다.
- LinkedHashMap은 컬렉션에 추가된 원소간의 순서를 보장한다.
- TreeMap은 키의 순서에 따라서 순차열람이 가능하지만 원소 추가/삭제 시간이 logn에 비례한다.


## Collections
- Collections는 다른 컬레션 인터페이스에 넣기 적절치 않은 기능들을 모아놓은 유틸 클래스이다.
> reverse(), copy(), swap(), get(), binarySearch() 등

###  Collections가 제공하는 기능들
### 1. 검색
- indexOf() 연산에 걸리는 시간은 리스트의 크기에 비례한다. 그러나 원소들이 정렬되어 있다면 이진 검색을 사용해서 logN에 비례하는 시간에 검색할 수 있다. 
- Collections.binarySearch(list, ele)를 사용하면 좀더 효율적으로 원소에 대한 인덱스를 구할 수 있다. 해당 원소가 리스트에 없으면 음수를 반환한다. 
- 이진 검색은 ArrayList와 같이 상수 시간에 임의의 접근이 가능한 리스트에 대해서만 향상된 성능을 제공한다.

### 2. 정렬
- 원소간의 순서를 바꾸는 연산 제공
    - reverse(list) : 리스트에 속해 있는 모든 원소간의 순서를 거꾸로 바꿈
    - shuffle(list) : 순서를 임의로 바꾼다.
- 정렬을 수행하면 컬렉션의 원소들이 일단 배열로 복사되어 정렬된 후 다시 본래 컬렉션으로 복사되기 때문에 정렬의 성능은 ArrayList, LinkedList 둘다 비슷하다.

### 3. 수정 불가능한 컬렉션
- 전달되는 컬렉션의 변경을 허용하고 싶지 않을때에 Collections로 래핑한 수 클라이언트가 컬렉션을 수정하려 하면 예외를 발생시키도록 처리 할 수 있다.
(Collection, List, Set, Map에도 비슷하게 적용 가능)
    ```java
    @Test(expected = UnsupportedOperationException.class)
    public void unmodifiableThrowException(){
        List<String> II = new ArrayList<String>();
        II.add("zz");

        Collection<String> strings = Collections.unmodifiableCollection(II);
        Iterator<String> all = unmodifiable.iterator();
        all.next();
        all.remove();
    }
    ```

### 4.단일 원소 컬렉션
- 하나의 원소를 전달해야하지만 컬렉션 인터페이스를 사용해야 하는 경우, Set을 반환하는 
`Collections.singleton()`을 사용할 수 있다.
    ```java
    Set<String> short = Collections.singleton("A");
    List<String> short = Collections.singletonList("A");
    Map<String, String> short = Collections.singletonMap("K", "V");
    ```
### 5. 무원소 컬렉션
- 컬렉션 인터페이스를 사용해야 하지만 전달할 원소가 없는 경우에는 Collections에서 수정할 수 없는 무원소 컬렉션을 생성해서 사용할 수 있다.
    ```java
    Collections.emptyList()
    ```

## 컬렉션 확장
- 컬렉션에서클래스를 상속받아 확장 할 수 있다.
- 이 경우 컬렉션에서 제공하는 많은 연산들이 클라이언트측에 부적절 할 수 있다. (clear()등)
- 몇줄 안되는 유용함을 위해서 상속을 사용해 버려 더 유용하게 쓰일 상속을 못하게 될 수 있다.
- 상속보다는 위임을 사용하는 편이 낫다
    ```java
    class Library {
        Collection<Book> books = new ArrayList<book>();
    }
    ```
- 범용 컬렉션 클래스를 구현하는 경우에만 컬렉션을 상속받게 하고, 다른경우에는 위임을 사용해서 내부 컬렉션에 원소들을 저장하라.
