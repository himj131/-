# 발전하는 프레임워크

대부분의 경우 커뮤니케이션에 드는 비용에 비해 코드 수정에 드는 비용이 훨씬 저렴하지만, 프레임워크 개발의 경우에는 프레임워크를 사용하는 모든 클라이언트가 코드를 변경해야 하므로 수정비용이 더 비싸다. 따라서 호환성을 깨뜨리는 업데이트는 피하는 것이 좋다.

## 애플리케이션 수정 없이 프레임워크 수정하기
- 프레임워크를 지속적으로 발전시키면서 기존 클라이언트 코드는 계속해서 동작하도록 해야한다.
- 보통의 개발 과정에서는 복잡도를 최소로 하는 것이 코드 이해를 쉽게 하는 좋은 전략이지만, 프레임워크 개발에서는 기존 클라이언트 코드의 동작을 보장하면서 프레임워크를 발전 시켜야 하므로 그를위한 복잡도를 어느정도 높이는 것이 더 효율적인 경우가 많다.
-프레임워크를 개발할때는 복잡도를 낮출만한 발전의 여지를 남겨두면서도, 단순해서 손쉽게 사용할 수 있어야 한다. 또한, 적용범위의 확장성을 남겨두면서도 당장 사용할 수 있는 적용성을 지녀야 한다.

## 호환성 없는 업그레이드 
- 병렬 아키텍처 
    - 부분 업그레이드로 해당 기능을 더이상 지원하지 않아도 한두번의 릴리즈에서 해당 기능을 제공하여 그 기간동안 클라이언트가 새로운 api로 옮겨갈 수 있다
    - 이런 병렬 아키텍처는 복잡도를 높이지만 업그레이드로 인한 문제점을 줄여준다.
- 패키지 사용
    - 기존 클래스의 이름을 그대로 사용한 새로운 클래스를 새로운 패키지에 넣는다.
    - 클라이언트는 업그레이드 반영시 import문만 수정하면 되므로 실제 코드를 바꾸는 것보다 위험도가 낮다.
- api,구현을 점진적으로 바꾸기
    - 인터페이스를 바꾸거나 구현을 바꾼 중간 릴리즈 코드는 프레임워크를 제공하는 측과 사용하는 측 모두에게 변화의 방향에 익숙해질 시간을 제공한다. 

- 프레임워크에서 중요한 또 다른 사항은 퇴보한 기능을 언제까지 지원하느냐이다.  빠른 시일내에 프레임워크를 발전시키는 것과 안정적인 버전을 사용하고자 하는 클라리언트의 필요성 사이에서 균형을 맞추는 것이 좋다.
- 기존 클라이언트 코드에 영향을 주지 않으면서 새로운 기능을 제공하는 호환성을 유지해주는 업그레이드가 베스트


## 호환성을 유지하는 업그레이드
- 후방 호환성  
    : 업그레이드를 통해 프레임워크에 구형 메소드 호출과 구형 객체 전달을 지원
- 전방 호환성  
    : 업그레이드를 통해 신형 스타일의 객체를 클라이언트에 전달해도 동작하도록 하는것

### 라이브러리 클래스
- 라이브러리 클래스를 사용하면 복잡도를 높이지 않으면서도 미래에 대비할 수 있다.
- 새로운 버전의 라이브러리 클래스를 릴리즈해도 기존 메소드가 이전과 같게 동작하는지만 확인하면 된다.
- 새로운 버전의 라이브러리 클래스에서는 기존 기능들을 그대로 놔둔채 새로운 정적 메소드를 추가한다.

### 객체
- 프레임워크를 객체로 나타낼 때에는 네가지 이슈가 있다.
    1. 사용 스타일 : 인스턴스화 vs 상속
    2. 추상화 : 클래스 수준의 세부 사항을 인터페이스로 나타낼 것인가 클래스로 나타낼 것인가?
    3. 생성 : 어떻게 객체를 생성할 것인지
    4. 메소드 : 유용성과 유연성을 위한 메소드 구성은 어떻게 해야하나
#### 1. 사용 스타일
- 인스턴스화 
    - 가장 단순
    - 인스턴스가 생성되면 해당 객체에 대해 메소드를 호출하는 방식으로 프레임워크 사용
    - 클라이언트가 로직의 변형을 필요로 하지 않고 데이터의 변형만을 필요호 하는 경우 사용

- 설정 
    - 프레임워크 객체를 생성한 후 자신만의 객체를 프레임워크에 전달해서 프레임워크에서 사용되도록 한다.
    - 데이터뿐 아니라 로직의 변형도 지원하므로 인스턴스화보다 유연하다
    - 설정을 사용해 객체를 호출하는 경우, 계속해서 같은 인터페이스를 아용해야 하므로 프레임워크를 발전시키는 데 제한이 생기고 클라이언트 코드에 대한 호환성을 보장해주기 어려워진다.
    - 실직적으로 표현할 수 잇는 변형의 종류에도 제한이 있다.

- 구현
    - 클라이언트가 설정에서 제공하는 것 이상으로 많은 종류의 로직변형을 필요로 하는경우 구현을 사용한다.
    - 미래 설계 변경을 가장 크게 제한한다.  호환성 보장을 위해서 상위클래스나 인터페이스를 유지해야하기 때문
    - 프레임워크 추상화에서 세부 사항을 노출하게 되면 클라이언트는 자신의 코드를 사용할 수 있게 되지만, 프레임워크 개발자는 기존 클라이언트 코드와의 호환성을 포기 하지 않는 이상 같은 인터페이스를 계속 사용해야 한다.
    - 필요한 경우 프레임워크에서 제공하는 메소드에 원하는 변형만 구현하면 되기때문에 설정에 비해 표현할 수 있는 범위가 훨씬 넒다.

#### 2. 추상화 
- 인터페이스 
    - 인터페이스를 클라이언트에 제공할때의 이점은 세부 사항을 가급적 적게 드러낸다는 것이다.
    - 인터페이스를 사용할 경우 클라이언트 클래스가 여러 인터페이스를 동시에 구현할 수 있다는 장점이 있다.
    - 새로운 메소드를 인터페이스에 추가할 경우 모든 클라이언트 구현이 동작하지 않는다. 
    - 위 문제를 해결하기 위해 버전 인터페이스를 사용 할 수 있다. 하위 인터페이스를 만들어서 새로운 연산을 추가할 경우, 클라이언트는 기존 인터페이스가 필요한 경우에도 새로운 인터페이스를 사용할 수 있고 기존 인터페이스에 따라 작성한 코드도 계쏙 사용 가능하다.
    - 버전 인터페이스는 새로운 인터페이스에 있는 연산을 호출할 때마다 명시적으로 타입 변환을 해줘야 한다.
    - 버전 인터페이스의 경우 자주 변경되는 추상화에 오랜긴간 사용되기에는 어렵다. 자주 변경되는 추상화는 상위클래스를 사용해 좀더 깔끔하게 처리 할 수 있다.
- 상위클래스
    - 상위클래스를 사용하면 인터페이스보다 세부 사항을 나타낼 수 있으면서, 상위클래스에 새로운 메소드를 추가해도 호환성에 문제가 없다. 
    - 가급적 클래스에서 노출하는 세부사항을 줄여서 인터페이스에서 노출하는 정보 수준에 가깝게 해야한다.
    - 프레임워크의 필드는 언제나 전용이어야 한다. 필드 데이터에 접근해야 한다면 취득 메소드를 제공하라.
    - final을 사용하면 클라이언트에 노출된 메소드에 대해 언제나 어떤 메소드가 수행될지 보장해주지만 메소드 변형시 문제소지가 있을 수 있따
    - 프레임워크 내에서는 보이지만, 클라이언트에게는 보이지 않는 가시성을 필요로 하는데, 내부패키지를 사용하여 세부사항을 노출하는 것과 감추는 것의 중간 단계를 제공 할 수 있다.

#### 3. 생성
- 생성 금지
    - 클라이언트가 프레임워크 객체를 직접 생성하는것을 금지하는 옵션으로 가장 단순하지만 유용성은 떨어진다.
    - 너무 복잡한 프로그램이 아니라면, 클라이언트의 객체 생성을 허용하게 하는것이 좋다.
    - 프레임워크 개발자가 예측하지 못한 방식으로 유용하게 사용되어, 프레임워크의 가치를 높일수 있는 기회가 될 수 있다.
- 생성자 
    - 클라이언트가 생성자를 사용하는것ㄴ은 간단하지만 이후 프레임워크 수정에 제약이 된다.
    - 클라이언트 입장에서는 단순 명확하기 때문에 프레임워크에서 클래스의 패키지나 이름, 구상클래스를 바꾸지 않아도 괜찮을때 사용하면 좋다.
- 정적 공장
    - 클라이언트의 객체 생성은 복잡도가 올라가고, 프레임워크 개발자는 미래 설계에 유연성을 갖게 된다.
    - 객체 생성시의 변형을 클라이언트에게 좀더 명확히 전달 할 수 있다.(메소드 이름을 통해)
    ```java
    ArrayList.create()
    Collections.createArrayList()
    ```
- 공장 객체
    - 공장 객체는 정적 공장보다는 유연하지만 코드를 읽기 어려워진다. 
    - 공장 객체는 지역적으로 사용해야 좀더 효과적이다. 
    - 공장 객체는 함께 사용되는 클래스를 생성하는데 유용하게 사용할 수 있다. 

> 객체 생성을 어떻게 하느냐는 프레임워크의 사용과 수정의 용이성에 영향을 준다. 한가지 전략은 변화 할것 같은 객체에는 공장 메소드를 사용하고, 안정적인 클래스에는 생성자를 사용하는 것이다.

#### 4.메소드
- 클라이언트가 문제를 해결할 수 있도록 하되 가급적 세부사항은 적게 노출해야한다.
- 클라이언트가 내부 자료 구조에 의존하도록 하면 프레임워크를 수정하는 것은 어려워진다.
- 클라이언트가 값을 설정해 어떤 문제를 해결하려 하는지 파악하고 설정메소드를 공개하는 대신, 그 문제를 메소드 이름에 반영하는 것이 좋다.
- 부득이하게 설정메소드나 취득메소드를 구현해야 할 경우 메소드 이름에 내부 구현 대신 역할을 반영하도록 하자
- 이미 공개된 메소드에 파라미터를 추가할 경우에는 호환성 유지를 위해 기본값을 제공하라
    ```java
    //기존 메소드 호환
    public TestResult run(Class.. classes) {
        TestResult result = new TestResult();
        //신규 메소드 호출
        run(result, classes);
        return result;
    } 
    ```

## 맺음말
프레임워크 개발에서 경제성을 결정짓는 요소는 코드 이해에 대한 비용이 아닌 기존 클라이언트 코드를 업그레이드 하는 비용에 의해 결정된다.  
애플리케이션 개발에서는 단순성이 가장 중요한 요소이지만, 프레임워크의 개발에서는 확장성에 비해 단순성의 우선순위가 떨어진다. 프레임워크를 통해서는 사용자들의 공통적인 문제만 해결해주고, 사용자 개별 문제까지 해결할 필요는 없다.   
