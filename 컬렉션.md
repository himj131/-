# 컬렉션
- 컬렉션 구현은 주로 성능에 관련된 프로그래머의 의도를 전달한다.
- 컬렉션은 프로그래밍에 있어 가장 근본적인 변형인 몇개의 데이터를 사용하느냐를 표현
- 로직의 변형은 조건문이나 다형성 메시지를 통해 표현할 수 있고
- 데이터 개수의 변형은 컬렉션에 데이터를 넣는것으로 표현한다. 
- 어떤 컬렉션을 사용하느냐에 따라 프로그래머는 다양한 정보를 독자에게 전달 할 수 있다.

## 컬렉션 메타포
### 1. 여러값을 가진 변수
- 컬렉션 변수는 여러 객체를 한번에 가리키는 역할을 한다. 
- 여느 변수와 마찬가지로 컬렉션 변수에도 값을 할당하고, 값을 얻어올수 있으며 변수 메세지를 보낼 수 있다.

### 2. 객체
- 컬렉션의 값을 얻는것도 가능하고, 인자로 전달하는것도 가능하며 동등성 테스트, 메세지 보내기가 가능하다. 
- 컬렉션은 여러 관련있는 인터페이스와 구현의 집합이므로 확장된 인터페이스와 새로운 구현을 통해 확장이 가능하다.
- 변수 값이 아닌 변수 자체를 인자로 전달하는 참조 호출이 가능해지고, 

### 3. 수학적 집합
- 수학의 집합이 여러 원소의 모임인 것과 마찬가지로 컬렉션은 객체의 모임이다.
- 집합 메타포를 모두 컬렉션에 적용하지는 않고, 크기(size())를 구하는 것이나, 집합에 속해있는지 알아보는(contains())것 등의 부분적으로만 적용된다.

## 이슈
- 컬렉션을 사용할때에는 가급적 가장 일반적인 인터페이스를 사용해서 선언하고, 가장 구체적인 구현 클래스를 사용하는 것이 좋다. 
    > 같은 객체를 Iterable, Collection, List등 다양한 타입을 사용하는 것보다 모든곳에서 List로 선언하는 것이 더 깔끔할 수 있다.
- 컬렉션의 선택은 성능에 관한 프로그래머의 의도를 전달한다.  
- 적절한 컬렉션 사용은 시간과 공간면에서 모두 프로그램을최적화 시킬수 있다.

## 컬렉션으로 표현하는 개념
- 크기 : 고정크기 가변형
- 원소간의 순서 : 순서정보가 보전되어야 하는지
- 원소의 독자성 (uniqueness) : 어떤 원소가 컬렉션에 속해있는지 여부나, 몇번 나타나는지
- 접근 : 순차 열람 or 키를 통해 원소를 가져올것인지

> 성능과 컬렉션 사이에 밀접한 관계가 있는 이유는 컬렉션의 크기에 제한이 없기 때문이다. 성능에 중점을 둔 컬렉션을 사용한 프로그래밍을 할 때 가장 단순한 구현으로 시작해서, 필요에 따라 좀더 특화된 컬렉션을 사용하는것을 권장한다. 
성능과 관련된 결정을 내릴때면 설계에 어느정도 변화가 필요하더라도 그 변화에 따른 영향 범위가 최소한이 되도록 노력한다.


## 인터페이스
### 배열
- 가장 단순한 컬렉션 인터페이스
- 배열의 크기는 생성시 고정
- 단순 연산의 경우 다른 컬렉션에 비해 시간, 공간면에서 효율적이다
- 다른 컬렉션과 다른 프로토콜을 갖고있어 배열을 다른 종류의 컬렉션으로 별환하는 일이 상대적으로 복잡하다.

### Iterable
- 지원하는 기능은 순차 열람 뿐이고 크기 측정 메소드도 없다.
- 수정에 대한 여부를 판단할 수 없고 Iterator를 갖고 있다면 remove()메소드를 사용해서 원소를 제거할 수 는 있다.
- Iterable의 하위 인터페이스들이 좀더 유용한 기능을 지원한다.

### Collection
- Iterable을 상속받아 원소 추가, 삭제, 검색, 크기등의 메소드를 추가로 지원한다.
- addAll(), retainAll(), removeAll()의 결과로 컬렉션 자체를 바꾸는 대신 새로 할당된 컬렉션을 반환한다.

### List
- Collection을 기반으로 원소간에 정해진 순서을 부여한 것
- List를 사용하면 컬렉션상에서의 인덱스를 통해 어떤 원소네 접근할 수 있다.
- 원소 사이의 상호작용(특히 원소간의 순서)이 있는 경우 사용한다.

### Set
- 중복 원소를 허용하지 않고, 순서가 없는 컬렉션
- Set에 원소를 추가하면 변경된 컬렉션이 아닌 컬렉션 자체가 바뀐다.
- 컬렉션에 원소가 속해있는지 여부가 중요하고, 출현 횟수가 중요하지 않은 경우 유용

### SortedSet
- 중복 원소가 없는 순서가 있는 컬렉션
- SortedSet는 Comparator에 의해 순서를 정한다. (명시적인 순서를 정하지 않은 경우 기본 정렬)

### Map
- List처럼 키를 사용해 원소를 저장하고 이때 키는 임의의 객체가 된다.
- Map의 키는 중복이 불가하지만 원소데이터는 중복 사용이 가능하다.
- 순서가 보장 되지 않는다.
- Map은 내부적으로 키에 대한 컬렉션과 데이터에 대한 컬렉션, 2개의 컬렉션을 유지한다.
- 외재상태나 변수상태에 많이 사용아여 키를 객체로 테이터를 상태로 사용할때 유용하다.
