# 메소드
- 거대한 단일 메서드의 단점
    - 중요한 부분과 덜 중요한 부분을 구별하기 어렵다.
    - 같은 기능을 매번 다시 구현 해야한다.
- 여러개의 작은 단위로 된 메소드의 장점
    - 로직간의 연관성을 나타낼 수 있다. (분리된 메소드는 연관성이 적다)
    - 메소드 이름만으로 세부 구현과 상관 없이 로직의 목적 파악 가능하다.
- 프로그래밍을 하다보면 반복적으로 필요한 기능이 있는데 이럴 때 메소드를 만드는 것이 좋다.

## 메소드와 관련된 패턴
### 조합메소드
- <u>추상화 수준이 비슷한 메소드</u> 호출로 하나의 메소드를 구성하는 것
- 코드의 추상화 수준이 바뀌면 흐름이 깨져서 읽기 어려워진다.
- 일단 동작하는 코드를 만들고 구성 방식을 결정하라.
- 로직을 나눈후에도 코드가 읽기 어렵다면, 모든 메소드를 인라인 시켜 커다란 메소드를 만든후, 다시 나눠본다.

### 의도 제시형 이름
- 메소드의 이름을 통해서는 메소드의 의도만 전달. (그외 정보는 다른 방식으로 전달)
    ```java
    //구현 전략을 제시한 이름
    Customer.linearCustomerSearch(String id)

    //의도 제시형 이름
    Customer.find(String id)
    ```
- 메소드 이름은 그 메소드를 호출하는 입장에서 생각해보고, 호출자 의도에 맞게 지어야 한다.
- 기존 인터페이스와 비슷한 역할의 메소드를 구현한다면 인터페이스에서 사용된 이름과 같은 이름을 사용해라. 
    > Repository 를 상속하는 JpaRepository나 CrudRepository는 save(), findAll()등 Repository와 동일한 메소드명을 사용
- 구현하는 메소드가 기존 메소드와 비슷하지만 완전히 같지는 않을때는 접두어를 사용해 차이점을 나타내라. 
    > findbyId(), findAll(), findByType()...

### 메소드 가시성
- 메소드를 노출 시킬수록 객체에 대한 인터페이스를 수정하기는 어려워진다. 
- 가시성을 선택할때 고려할 두가지 비용
    1. 유연성 : 외부에 드러나는 인터페이스가 많지 않은 경우 미래에 인터페이스를 수정하는 것은 어렵지 않다. 
    2. 객체사용에 들어가는 비용 : 노출된 인터페이스가 많지 않은 객체를 사용할 경우, 사용하는 측에서 필요 이상으로 많은 작업을 해야한다. 
- 가시성 종류 
    - 공용(public) :   
        - public 메세지는 (패키지)외부에서도 이 메소드가 유용하다는 의미이다.
        - 프로그래머는 메소드를 수정할경우 모든 수정을 담당하거나, 다른사람에게 수정사항을 알려줄 책임이 있다.
    - 패키지(package) :  
        - 해당 메소드가 같은 패키지의 다른 객체에는 유용하고, 패키지 외부의 객체에는 공개하지 않음을 의미. 
        - package를 사용했다면 이 메소드를 pivate이나 public으로 선언하는게 낫지 않은지 고민해봐야 한다.
    - 보호(protect) :   
        - 하위 클래스를 사용해서 클래스를 재사용하려 할때 유용
    - 전용(private) :   
        - 외부 객체에게 이 메소드는 유용하지 않음을 의미
        - 유연성을 확보해준다.      
    - final 메소드 :  
        - 메소드 사용은 자유지만 메소드를 더이상 바꿀수 없음을 의미한다. 
        - 메소드 변경이 복잡하고 어려울때 사용하면 좋지만 메소드 오버라이드로 쉽게 해결할 수 있는지 고려 필요
    - static 메소드 :  
        - 다른 객체에서 해당 클래스의 인스턴스에 접근 할 수 없는 경우에도 메소드에 접근 할수 있다. 
        - 정적 메소드는 어떤 인스턴스의 상태에 의존할 수 없으므로 복잡한 로직을 구현하기 적합하지 않다. 
        - 정적 메소드는 상속이 가능하지만 오버라이드 된 경우에는 상위클래스의 메소드를 호출하는 것이 불가하다.

## 메소드 객체
- 복잡하게 꼬여있는 메소드를 읽기 쉽고, 세부구현전달이 쉽도록 바꿔준다. 
- 동작하는 코드가 나온 후 사용, 코드가 복잡할수록 효과가 크다.
- 메소드 객체를 만드는 과정 
    1. 메소드 이름을 딴 클래스 생성
    2. 메소드에서 사용하는 파라미터, 지역변수, 필드를 새로운 객체의 필드로 생성한다.
    3. 원 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다.
    4. 본래 메소드를 신규 클래스의 메소드로 복사한다.
    5. 기존 메소드의 본문을 새로운 객체의 인스턴스생성과 그의 메소드 호출로 바꾼다.
    6. 원래 메소드에서 필드설정하는 부분이 있다면 신규객체 메소드 호출 후 설정해준다.
    7. 기존과 같게 작동하는지 확징
- 메소드 객체를 사용하면 메소드 분리가 쉬워진다.(모든 데이터가 필드에 저장되어있어, 파라미터를 사용하지 않으므로)
- 메소드를 분화해 나가면서 기존에 분리하기 어려웠던 공통된 부분을 의미있는 이름을 가진 도우미 메소드로 바꿀 수 있다.

## 오버라이드
- 변형 메소드를 표현
- abstract 메소드 외에도 final메소드만 아니라면 기존연산의 변형이 가능하다.
- 하위클래스에서 메소드 오버라이드를 해도 `super.method()`를 호출해 상위클래스의 메소드를 사용할 수 있지만 같은 메소드이름에서만 호출하는 것이 좋다
- 상,하위 클래스의 여러 메소드를 혼합해 사용하면 클래스의 크름을 이해하기 어렵고 오류가능성이 높아진다.

## 오버로드
- 서로 다른 파라미터를 사용해 같은 메서드를 선언
- 메소드 사용을 확인하기 위해 이름과 파라미터까지도 살펴봐야 한다는 단점이 있다
- 파라미터 타입만 다를뿐, **같은 연산**을 수행해야 한다. 
- 의도가 다르다면 다른 이름의 메소드를 만드는것이 좋다.

## 메소드 반환 타입
- 함수 작성시 의도를 나타내는 반환타입을 사용해라
- 메소드의 적용 범위를 넓히기 위해 의도를 드러낼 수 있는 가장 추상적인 타입을 사용하라
- 반환타입을 일반화 하면 세부 구현을 숨길 수 있다.
- 관련 메소드에서 각각 다른 클래스를 반환하게 되는 경우에는, 각 클래스가 같은 인터페이스를 공유한다면 유사점과 차이점을 좀더 명확하게 나타낼 수 있다. 이런경우에는 공용 인터페이스를 선언하고 모든 메소드에서 새로 선언한 인터페이스를 반환하게 하는것이 좋다.

## 메소드 주석
- 코드만으로 분명하지 않은 정보는 주석을 사용해서 전달하라.
- 필요한 경우 javadoc주석을 사용해서 클래스와 메소드의 목적을 설명하라.
- 메소드 사이에 제약이 있는 경우 주석을 달아도, 항상 코드와 주석의 변경을 함께 하는지 알 수 없다.
- 자동화된 테스트로 메소드 주석으로 표현할 수 없는 내용을 전달 할 수 있다.
- 구현 전의 테스트 작성은 설계 연습에 도움이 된다.
- 테스트 동작으로 테스트와 코드의 일관성을 보장해 줄 수 있다.

## 도우미 메소드
- 당장 관련도가 떨어지는 세부구현을 숨기고 메소드 이름을 통해 프로그래머의 의도를 나타내기 위해 사용
- 메소드 로직이 불명확하다면 도우미 메소드를 인라인하고 새로운 시각에서 로직을 바라본후 분리해라.

## 디버그 출력메소드
- toString() 을 통해 어떤 객체의 정보들을 손쉽게 알 수 있다. 
- toString()은 남용하기 쉽고 수정이 많이 되기 때문에 프로그래머에게 유용한 객체의 정보를 알려주기 위해 사용하는 것이 좋다.
- 그 밖의 문자열 정보는 다른 메소드나 다른 클래스를 통해 표현하라

## 변환
- 객체 A를 가진 상태에서 이후 연산을 위해 객체 B가 필요한 경우 '변환'을 사용한다.
- 변환을 효과적인 표현을 위해 고려해야할 사항
    1. 변환이 얼마나 많이 필요한지
    2. 클래스간의 의존성 : 변환을 편리하게 표현하려고 새로운 의존성을 만드는 것은 바람직 하지 않다.
### 변환의 구현
- 기존객체의 정보를 복사해서 새로운 타입의 실제 객체를 생성
- 기존객체에서 정보를 복사하지 않고 대상 객체에 대한 인터페이스 구현
- 실제 편환을 하지 않고 두 객체간의 공통 인터페이스를 찾아서 인터페이스를 통해 코드 작성

### 변환 메소드
- 유사한 타입의 객체간 변환을 표현할때 필요한 변환의 수헤 제한이 있다면, 기존 객체에 메소드 추가
```java
class Polar{
    //변환 메소드의 반환타입이 대상 객체이다.
    Cartesian asCartesian() {
        ...
    }
}
```
- 가독성이 좋다
- 하나의 원본 메소드를 만들기 위해서는 원본 객체의 프로토콜을 변경해야 한다.
- 원본 객체와 대상 객체 사이에 의존성을 생성한다. 
- 필요한 변환의 수가 제한되지 않은 경우 다루기 어려워진다. 이 경우 클라이언트에서 원본 객체를 다루게 하는편이 낫다.
- 변환 메소드는 주로 유사한 타입의 객체 사이 변환에 사용한다.

### 변환 생성자
- 원본 객체를 파라미터로 취해서 대상 객체를 반환한다. 
- 하나의 원본 객체를 여러 다른 대상 객체로 변환할 때 유용하다.

## 생성
- 크기가 작은 프로그램은 큰 프로그램에 비해서 수정하기 쉽다.
- 프로그램 수정을 쉽게 하기 위한 초기 전략은 커다란 프로그램을 수행하는 하나의 컴퓨터를 더 작은 여러개의 컴퓨터(객체)로 나누는 것이었다.
- 객체 사용으로 인해 프로그램 수정비용이 낮아졌다.

## 완결 생성자
- 생성자에서 연산을 할 수 있는 객체를 반환하도록 해서 사용자들에게 연산을 위한 선결 조건을 전달하라
- 객체 설정 방법이 여러가지라면 각 경우마다 제대로 된 객체를 반환하는 생성자를 제공하라.
```java
new Rectangle(0, 0, 50, 200);
```
- 생성자를 호출하는 코드를 작성하면 바로 구상 클래스를 사용할 수 있다.
- 공장 메소드를 사용하는 경우에도, 독자들이 인터페이스만 보고 객체 생성을 위해 어떤 정보가 필요한지 이해할수 있도록 완결된 형태의 생성자를 제공하라
- 완결 생성자를 구현할 때는 모든 생성자가 동일한 하나의 생성자를 사용해서 모든 초기화를 하도록 하라.

## 공장 메소드
- 정적 메소드는 추상타입을 반환할 수 있으며 의도가 담긴 별도의 이름을 가질 수 있다. 
- 객체를 생성하는 것보다 복잡한 작업(객체를 캐쉬저장, 런타임시 타입이 결정되는 하위 클래스 반환등)을 할때 유용
- 공장 메소드를 사용하면 복잡성이 증가 하고 가독성에 좋지 않다.
- 평범한 객체 생성르 하는 경우에는 생성자를 사용하고, 객체 생성이외에 다른 의도가 있는 경우 공장 메소드를 사용하라

## 내부 공장
- 객체 생성 과정이 복잡하거나, 하위클래스에 따라 달라질 경우에 사용
- 게으른 초기화를 사용하는 경우 흔히 사용되는 패턴
```java
getX() {
    if(x == null) {
        x = ...; // 이 부분이 길어지면 내부 공장 사용
        return x;
    }
}

getX() {
    if(x == null) {
        x = compute();
        return x;
    }
}
```
## 컬렉션 접근자 메소드
- 컬렉션에 대한 접근을 위해 취득메소드를 제공하면 유연함을 얻을수는 있지만, 사용자가 컬렉션을 직접조작 하므로 컬렉션 데이터 내무 상태가 유요하지 않을 수 있다.
- 컬렉션을 반환하기 전 수정할 수 없는 컬렉션 형태로 바꿔서 반환할 수 있지만 디버깅 비용이 증가한다
- 위와같은 방법들을 대신해 컬렉션에 대한 제한적이지만 의미 있는 접근을 제공하는 메소드를 사용하라.
```java
//book 추가
void addBook(Book arrival) {
    books.add(arrival);
}

//개수
int bookCount() {
    return books.size();
}
```

-사용자가 컬렉션 원소에 접근필요할때 순차열람자를 반환
```java

Iterator getBooks() {
    return books.iterator();
}
```
- 컬렉션 내용을 수정하는것을 금지하고 싶은 경우에는 컬렉션 원소를 제거할 때 예외를 던지는 순차열람자를 반환하라.
- 컬렉션 프로토콜을 중복해서 구견하고 있다면, 설계상의 문제가 있을 확률이 높다.
- 객체에서 클라이언트가 필요로 하는 적합한 작업을 제공한다면 내부 데이터 접근을 많이 허용할 필요가 없다.

## 불린 설정 메소드
- 불린 상태를 설정하는 메소드 
```java
void setValid(boolean newState) {
    ...
}
```
- 설정메소드의 인자가 언제나 상수값(참/거짓)이라면 각 bollean 상태마다 메소드를 제공해 명확히 표현 할 수 있다.
```java
void valid(){..}
void invalide(){...}
```
- 아래와 같이 boolena값 별로 행위가 달라지는 코드가 같이 있는 경우에는 setValidity(boolean) 형태의 메소드가 낫다.
```java
...
if(...boolean expresstion...) {
    cache.valid();
} else {
    cache.invalid();
}
```

## 질의 메소드
- 객체가 다른 객체의 결정을 도와야 할 경우에는 be동사나 have 동사를 사용하라
- 어떤 객체가 다른 객체의 상태에 의존적인 로직을 많이 갖고 있으면, 로직의 위체 문제가 있다는 신호이다.
```java
if(widget.isVisible()) {
    widget.doSomethin();
} else {
    widget.doSomeThingElse();
}
```
위와 같은 코드에서는 widget객체에 적당한 메소드를 넣어주는 편이 낫다.

## 동등성 메소드
- 객체의 동일성이 아닌 동등성을 비교할때는 eqauls() 와 hashCode()를 구현하다.
    > **동일하다** 는 두 개의 오브젝트가 완전히 같을 경우를 의미하고,  
    > **동등하다** 는 두 오브젝트가 같은 정보를 갖는 경우를 의미.
    ```java
    //
    public boolean equals(Object other) {
        if( ! other instanceof Instrument)
            return false;
        Instrumnet instrument = (Instrument) other;
        return getSerialNumber().equals
        (instrument.getSerialNumber());
    }

    //해쉬값을 구할때도 시리얼 넘버만 사용
    public int hashCode() {
        return getSerialNumber.hashCod();
    }
    ```
    - equal, hashCode를 사용하려면 규칙을 따라야 한다.
        - equals 메서드는 동치관계(equivalence relation)을 구현한다.   
            - 반사성(reflexive) : null이 아닌 참조가 x있을 때, x.equals(x)는 true를 반환한다.  
            - 대칭성(symmetric) : null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.  
            - 추이성(transitive) : null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.
            - 일관성(consistent) : null이 아닌 참조 x와 y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출결과는 호출 횟수에 상관없이 항상 같아야 한다.  
            - null이 아닌 참조 x에 대해서 x.equals(null)은 항상 false이다.
        - hashCode() 메서드   
            - 메모리 주소가 다른 객체는 같은 해시코드 값을 가질 수 없음  
            - HashCode는 HashMap 같은 해싱 알고리즘을 사용하는 자료구조에 주로 사용함
            - equals를 오버라이딩 할 경우, hashCode도 오버라이딩 해야함
    - 동등성 고민을 피하고 싶다면 2개의 수정 불가능한 객체가 동등할때 둘은 언제나 같은 객체임을 보장해주는 기법을 쓴다.
    ```java
    static Instrument create(String serialNumber) {
        if(cache.containsKey(serialNumber))
            return cache.get(serialNumber);
        Instrument result = new ?Instrument(serialNumer);
        cache.put(serialNumber, result);
        return result;    
    }
    ```


## 취득 메소드
- public이나 package 가시성을 갖는 취득메소드는 다른곳에 로직이 있다는 힌트가 된다.
- 이 경우, 가급적 필요한 로직을 데이터가 있는 쪽으로 옮겨보는 것이 좋다.
- 여러 객체를 이용해서 알고리즘을 구현할때에는 데이터 접근을 위해 공용 취득 메소드를 사용한다. 
- 내부 취득 메소드는 게으른 초기화나 캐쉬를 구현할 경우 유용하다.

## 설정 메소드
- 설정 메소드는 'set'이라는 접두어를 붙인다.
- 설정 메소드를 사용하면 코드에 문제가 발생하기 쉽다. 따라서 외부에서 설정 메소드의 사용은 피하는 것이 좋다.
- 설정 인터페이스를 통해 유용한 인터페이스를 구현할 수 있다면 설정메소드 사용도 괜찮다.
- 설정 메소드의 이름은 클라이언트 입장에서 지어야 한다.
```java
paragraph.setJustification(Paragraph.CENTER);

//메소드 목적에 따라 인터페이스 이름을 정하기
paragraph.centered();
```
- 내부적으로 설정 메소드를 사용하는 것은 의존적인 정보를 업데이트 하는 경우에 유용하다.
```java
private void setJustification(){
    ...
    redisplay();
}
```
- 어떤 도구에서 설정 메소드를 호출해야 한다면 '도구 전용' 이라는 주석을 붙인 후 해당 메소드를 공용으로 만들어라

## 안전한 복사
- 취득 메소드나 설정 메소드를 사용하면 앨리어스 문제가 발생한다.
- 객체를 반환하거나 저장하기 전에 복사본을 만드는 방식으로 이런문제를 해결함
    ```java
    //안전한 복사(get)
    List<Book> getBooks() {
        List<Book> result = new ArrayList<Book>();
        result.addAll(books);
        return result;
    }

    //안전한 복사(set)
    void setBooks(List<Book> newBooks) {
        books = new ArrayList<Book>();
        books.addAll(newBooks);
    }
    ```
- 앨리어스문제를 피하기 위해 안전한 버전의 메소드를 수행하면 거대한 객체가 복사되서 성능이 저하됐다.
- 외부접근에서 코드를 보호하는 일시적인 해결책이므로 핵심 기법으로 사용하는 것은 피하는 것이 좋다.


